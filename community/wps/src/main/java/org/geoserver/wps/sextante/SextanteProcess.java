/* Copyright (c) 2001 - 2007 TOPP - www.openplans.org. All rights reserved.
 * This code is licensed under the GPL 2.0 license, available at the root
 * application directory.
 */
package org.geoserver.wps.sextante;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import org.geotools.data.DataUtilities;
import org.geotools.data.FeatureSource;
import org.geotools.data.Query;
import org.geotools.feature.FeatureCollection;
import org.geotools.process.Process;
import org.opengis.util.ProgressListener;

import es.unex.sextante.core.GeoAlgorithm;
import es.unex.sextante.core.ITaskMonitor;
import es.unex.sextante.core.OutputObjectsSet;
import es.unex.sextante.core.ParametersSet;
import es.unex.sextante.dataObjects.IDataObject;
import es.unex.sextante.exceptions.GeoAlgorithmExecutionException;
import es.unex.sextante.exceptions.WrongParameterIDException;
import es.unex.sextante.outputs.Output;
import es.unex.sextante.parameters.Parameter;
import es.unex.sextante.rasterWrappers.GridExtent;

public class SextanteProcess implements Process{

	/**
	 * A constant to use as a key to identify the output grid extent
	 * as another input parameter of the process. In a SEXTANTE
	 * algorithm this is not a parameter included in the parameters set.
	 */
	public static final Object GRID_EXTENT = "GRID_EXTENT";

	private GeoAlgorithm m_Algorithm;

	/**
	 * Constructs a new process based on a SEXTANTE geoalgorithm
	 * @param algorithm the SEXTANTE geoalgorithm
	 */
	public SextanteProcess(GeoAlgorithm algorithm) {

		m_Algorithm = algorithm;

	}

	public Map<String, Object> execute(Map<String, Object> input,
			ProgressListener monitor) {

		ITaskMonitor taskMonitor = new ProgressListenerTaskMonitor(monitor);

		try {
			setAlgorithmInputs(input);

			/*
			 * Execute the algorithm
			 * The output factory tells the algorithm how to create
			 * new data objects (layers and tables)
			 * Since we are working with GeoTools , we use the
			 * GTOutputFactory, which creates objects based on geotools
			 * data objects (DataStore and GridCoverage)
			 */

			if (m_Algorithm.execute(taskMonitor, new GTOutputFactory())){
				return createReturnMapFromOutputObjects();
			}
			else{
				//if the execution was canceled, we return null
				return null;
			}

		} catch (GeoAlgorithmExecutionException e) {
			e.printStackTrace();
			return null;
		}

	}

	/**
	 * Creates a suitable return map for this process
	 * from the outputs generated by the SEXTANTE algorithm
	 * @return a map with algorithm results
	 */
	private Map<String, Object> createReturnMapFromOutputObjects() {
		try {
			Map<String, Object> results = new HashMap<String, Object>();
	
			OutputObjectsSet outputs = m_Algorithm.getOutputObjects();
			for (int i = 0; i < outputs.getOutputObjectsCount(); i++) {
				Output output = outputs.getOutput(i);
				Object outputObject = output.getOutputObject();
				// if the output object is a layer or a table, we return
				// the inner GeoTools object
				if (outputObject instanceof IDataObject){
					IDataObject dataObject = (IDataObject) outputObject;
					Object wrapped = dataObject.getBaseDataObject();
					if(wrapped instanceof FeatureSource) {
						results.put(output.getName(), ((FeatureSource) wrapped).getFeatures());
					} else {
						results.put(output.getName(), wrapped);
					}
					
				}
				else{
					results.put(output.getName(), outputObject);
				}
			}
			return results;
		} catch(Throwable t) {
			throw new RuntimeException(t);
		}

	}

	/**
	 * Sets the input of the SEXTANTE algorithm from the input map
	 * of this process
	 * @param input the input map of this process
	 * @throws WrongParameterIDException
	 */
	private void setAlgorithmInputs(Map<String, Object> input)
						throws WrongParameterIDException {

		ParametersSet paramSet = (ParametersSet) m_Algorithm.getParameters();
		Set<String> keys = input.keySet();
		Iterator<String> iter = keys.iterator();
		while(iter.hasNext()){
			String sKey = iter.next();
			if (!sKey.equals(GRID_EXTENT)){
				Object paramValue = input.get(sKey);
				Parameter param = paramSet.getParameter(sKey);
				if(paramValue instanceof FeatureCollection) {
					param.setParameterValue(GTVectorLayer.createLayer(DataUtilities.source((FeatureCollection) paramValue), Query.ALL));
				} else {
					param.setParameterValue(paramValue);
				}
			}
			GridExtent ge = (GridExtent) input.get(GRID_EXTENT);
			m_Algorithm.setGridExtent(ge);
		}

	}

}
